\section{(Любительская) криптография}
\label{crypto}

\subsection{\textit{Серьезная} криптография}

Вернемся к раннее использованнму методу (\ref{symbolic_exec}), чтобы сконструировать выражения используя запущенную
Питоновскую ф-цию.

Можно найти выражения для всех четырех выходов алгоритма шифрования XXTEA:

\lstinputlisting{crypto/xxtea.py}

Ключ выбирается в зависимости от входных данных, и, очевидно, мы не знаем его во время символьного исполнения,
так что мы оставляем выражение вроде \TT{k[...]}.

Теперь результаты для одного раунда, для каждого из 4-х выходов:

\lstinputlisting{crypto/1round.txt}

Каким-то образом, выражение для каждого последующего выхода больше. Надеюсь, я нигде не ошибся?
И это просто для одного раунда.
Для двух раундов, размер всех 4-х выражений $\approx 970KB$.
Для трех, это $\approx 115MB$.
Для четырех, у меня не хватило памяти на моем компьютере.
Выражения \textit{взрываются} экспоненциально.
А здесь 19 раундов.
Можете ощутить вес.

Вероятно, вы можете упростить эти выражения: здесь очень много лишних скобок,
но я очень пессимистичен, криптоалгоритмы и создаются таким образом, чтобы не иметь лишних операций.

Чтобы взломать его, вы можете использовать эти выражения как систему уравнений и попытаться решить её при помощи SMT-солвера.
Это называется ``алгебраическая атака''.

Другими словами, теоретически, вы можете построить систему уравнений вроде: $MD5(x)=12341234...$,
но эти выражения настолько огромные, что решить это нельзя.
Да, криптографы прекрасно осведомлены об этом и одна из задач успешного шифра в том, чтобы сделать выражения
настолько большими, насколько это возможно, используя разумное время и размер алгоритма.

Тем не менее, вы можете найти много статей о взломе этих криптосистем учитывая сокращенное количество раундов:
пока вырежение еще не \textit{взорвалось}, иногда это возможно.
Это не применимо затем на практике, но подобный опыт имеет некоторые интересные теоретические результаты.

\subsubsection{Попытки взлома ``серьезных'' шифров}

CryptoMiniSat сам по себе существует для поддержки операции исключающего ИЛИ, которая активно используется
в криптографии.

\begin{itemize}
\item Bitcoin mining with SAT solver: \url{http://jheusser.github.io/2013/02/03/satcoin.html}, \url{https://github.com/msoos/sha256-sat-bitcoin}.

\item \href{http://2015.phdays.ru/program/dev/40400/}{Александр Семенов, попытки взлома A5/1, итд. (на русском)}

\item \href{https://yurichev.com/mirrors/SAT_SMT_crypto/thesis-output.pdf}{Vegard Nossum - SAT-based preimage attacks on SHA-1}

\item \href{https://yurichev.com/mirrors/SAT_SMT_crypto/166.pdf}{Algebraic Attacks on the Crypto-1 Stream Cipher in MiFare Classic and Oyster Cards}

\item \href{https://yurichev.com/mirrors/SAT_SMT_crypto/Attacking-Bivium-Using-SAT-Solvers.pdf}{Attacking Bivium Using SAT Solvers}

\item \href{https://yurichev.com/mirrors/SAT_SMT_crypto/Extending_SAT_2009.pdf}{Extending SAT Solvers to Cryptographic Problems}

\item \href{https://yurichev.com/mirrors/SAT_SMT_crypto/sat-hash.pdf}{Applications of SAT Solvers to Cryptanalysis of Hash Functions}

\item \href{https://yurichev.com/mirrors/SAT_SMT_crypto/slidesC2DES.pdf}{Algebraic-Differential Cryptanalysis of DES}

\end{itemize}

\subsection{Любительская криптография}

Это то, что вы можете найти в серийных номерах, ключах с лицензиями, запаковщиками исполняемых файлов, \ac{CTF},
малварь (зловреды), итд.
Иногда даже в ransomware (но в наше время (2017) редко).

Любительскую криптографию очень часто можно взломать используя SMT-солвер, или даже KLEE.

Любительская криптография обычно основывается не на теории, а на визуальной сложности:
если её создатель получает результаты, которые выглядят достаточно хаотичными, часто, он прекращает разрабатывать его далее.
Это даже не безопасность через запутанность (\textit{security through obscurity}),
а даже безопасность через хаотическую путанницу.
Иногда это называется ``The Fallacy of Complex Manipulation''
(см.также \href{https://tools.ietf.org/html/rfc4086}{RFC4086}).

Разработка своего собственного криптоалгоритма это не такая уж и простая вещь.
Это можно сравнить с разработкой своего собственного \ac{PRNG}.
Даже знаменитый Дональд Кнут создал свой в 1959, и визуально он был очень сложным,
но как потом выяснилось на практике, у него был очень короткий цикл длиной 3178.
[См.также: The Art of Computer Programming том.II стр.4, (1997).]
% TODO cite Russian

Самая первая проблема это создание алгоритма, который может генерировать очень длинные выражения.
Частая ошибка это использование операций вроде исключающего ИЛИ и сдвигов/перестановок, что не очень сильно помогает.
Даже хуже: некоторые люди думают, что применение операции исключающего ИЛИ несколько раз может сделать лучше,
например: $(x \oplus 1234) \oplus 5678$.
Очевидно, эти две операции (точнее, любое их количество) можно сократить до одной.
Та же история с применением операций вроде сложения и вычитания --- они все могут быть сокращены до одной операции.

Настоящие криптоалгоритмы вроде IDEA могут использовать несколько операций из разных групп, как исключающее ИЛИ,
сложение и умножение.
Применение их всех в определенном порядке сделает итоговое выражение несократимым.

Когда я готовил эту статью, я попробовал сделать пример любительской хэш-функции:

\lstinputlisting{crypto/1.c}

KLEE может сломать её без особого труда.
Фцнкции такой сложности часто присутствуют в shareware, которые проверяют лицензионные ключи, итд.

А вот как мы можем сделать работу KLEE труднее используя сдвиги, зависимые от входов,
и это делает количество возможных входных значений намного больше:

\lstinputlisting{crypto/2.c}

Сложение (или, как говорят криптографы, \href{https://yurichev.com/blog/modulo/}{модульное сложение}) может всё усложнить
еще сильнее:

\lstinputlisting{crypto/3.c}

В качестве упражнения, можете попробовать сделать блочный шифр, который KLEE не сможет сломать.
Это очень отрезвляющий опыт.
Но даже если вы и сможете, это не панацея, у криптографов есть еще масса криптоаналитических методов.

Итог: если вы имеете дело с любительской криптографией, вы всегда можете попробовать KLEE и SMT-солвер.
И даже более того: иногда у вас есть только ф-ция для дешифрования, и если алгоритм достаточно прост,
при помощи KLEE или SMT-солвера, можно вернуть всё назад.

Еще одна смешная вещь: если вы пытаетесь реализовать любительский криптоалгоритм на языке Verilog/VHDL чтобы запустить
его на \ac{FPGA}, может быть, с целями брутфорса, вы можете обнаружить, что инструменты \ac{EDA} могут оптимизировать
его во время синтеза (это слово, которое они используют вместо ``компиляция''), и может оставить этот криптоалгоритм
в намного меньшем размере, работающим быстрее, чем это было в начале.
Даже если вы попытаетесь реализовать \textit{в железе} алгоритм \ac{DES} с фиксированным ключом,
Altera Quartus может оптимизировать его первый раунд, и он будет немного меньше остальных.

\subsubsection{Ошибки}

Еще одна выдающаяся особенность любительской криптографии это ошибки.
Ошибки часто остаются невыявленными, потому что выход ф-ции шифрования визуально выглядит ``достаточно хорошим''
или ``достаточно запутанным'', так что создатель бросает работу над ним.

Это особенно справедливо для хэширующих ф-ций, потому что когда вы работаете над блочным шифром, вам нужны
две ф-ции (шифрование/дешифрование), в то время как хэширующая ф-ция одна.

Самый странный любительский криптоалгоритм виденный мною, шифровал только нечетные байты входного блока,
оставляя четные байты нетронутыми, так что входной текст частично присутствовал в итоговом зашифрованном блоке.
Это была ф-ция шифрования использованная в проверке лицензионного ключа.
Трудно поверить в то, что кто-то сделал это намеренно.
Скорее всего, это была просто незамеченная ошибка.

\subsubsection{XOR-шифры}

Самый простой любительский криптоалгоритм просто применяет исключающее ИЛИ используя некоторую таблицу.
В русском языке также применятся термин ``гаммирование''.
Может быть даже еще проще. Вот реальный алгоритм, который я однажды видел:

\begin{lstlisting}
for (i=0; i<size; i++)
    buf[i]=buf[i]^(31*(i+1));
\end{lstlisting}

Это даже и не шифрование, скорее, сокрытие или упрятывание.

Некоторые другие примеры простейшего криптоанализа XOR-шифров, есть в книге ``Reverse Engineering для начинающих''
\footnote{\url{http://beginners.re}}.

\subsubsection{Другие особенности}

\textbf{Таблицы} Часто приствует таблица/таблицы с псевдослучайными данными, которая/которые хаотично используются.

\textbf{Контрольная сумма} Конечные пользователи имеют склонность изменять коды лицензий, серийные номера, итд,
в надежде, что это как-то повлияет на работу программы.
Так что часто присутствует некоторая контрольная сумма: начиная с простого суммирования и \ac{CRC}.
Это близко к \ac{MAC} в настоящей криптографии (в русском языке применяются термины \textit{имитозащита/имитовставка}).

\textbf{Уровень энтропии} Может быть (намного) ниже, не смотря на то что данные выглядят случайными.

\subsubsection{Примеры}

\begin{itemize}

\item Популярный менеджер лицензий FLEXlm использовал простой любительский криптоалгоритм
(перед тем, как они переключились на \ac{ECC}), который легко можно было сломать.

\item Pegasus Mail Password Decoder: \url{http://phrack.org/issues/52/3.html} -
очень типичный пример.

\item Вы можете найти массу постов в блогах о взломе криптографии уровня \ac{CTF} используя Z3, итд.
Вот один из них: \url{http://doar-e.github.io/blog/2015/08/18/keygenning-with-klee/}.

\item Еще: \href{http://blog.cr4.sh/2015/03/automated-algebraic-cryptanalysis-with.html}{Automated algebraic cryptanalysis with OpenREIL and Z3}.
Кстати, это решение следит за состоянием каждого регистра на каждом EIP/RIP, а это почти то же самое, что и \ac{SSA},
которая активно применяется в компиляторах, и стоит изучения.

\item Массу примеров любительской криптографии я взял со старого сайта Fravia:
\url{https://yurichev.com/mirrors/amateur_crypto_examples_from_Fravia/}.

\item Книга Дмитрия Склярова --- ``Искусство защиты и взлома информации'' имеет много примеров и любительской криптографии,
и использования обычной криптографии с ошибками.

\end{itemize}

% subsection
\input{crypto/hash/main_RU}
%\input{crypto/XOR/main_RU}

