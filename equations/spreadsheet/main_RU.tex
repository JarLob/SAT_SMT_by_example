\subsection{Пересчет упрощенной электронной таблицы используя Z3Py}

\renewcommand{\CURPATH}{equations/spreadsheet}

% TODO cite?
Есть неплохая задача\footnote{\url{http://thesz.livejournal.com/280784.html}}:
напишите программу для пересчета упрощенной электронной таблицы, вот как такой:

\lstinputlisting{\CURPATH/test1}

Результат должен быть такой:

\lstinputlisting{\CURPATH/test1_result}

Как выясняется, хотя это и слишком, но это может решить MK85 без всякого труда:

\lstinputlisting{\CURPATH/spreadsheet_MK85.py}

( \url{.../spreadsheet_MK85.py} )

Всё что мы делаем это создаем пачку переменных для каждой ячейки, с названиями 
A0, B1, итд, целочисленного типа.
Все они сохраняются в словаре \textit{cells[]}.
Ключ это строка.
Затем мы парсим все строки из ячеек и добавляем их в список констрайнтов, в случае числа в ячейке: \textit{A0=123},
либо, в случае выражения в ячейке: \textit{A0=B1+C2}.
Тут есть небольшая подготовка строк: строка вроде \textit{A0+B2} становится \textit{cells["A0"]+cells["B2"]}.

Затем строка обрабатыватся Питоновским методом \textit{eval()}, который очень опасен
\footnote{\url{http://stackoverflow.com/questions/1832940/is-using-eval-in-python-a-bad-practice}}:
представьте, если конечный пользователь добавить в ячейку строку с каким-нибудь другим выражением?
Тем не менее, это хорошо служит нашим целям, потому что это простейший способ передать строку с выражением в Z3.

\subsubsection{Z3}

Исходный код почти такой же:

\lstinputlisting{\CURPATH/spreadsheet_Z3_1.py}

( \url{...spreadsheet/spreadsheet_Z3_1.py} )

\subsubsection{Unsat core}

Теперь проблема: что если здесь есть циркулярная (круговая) зависимость? Например:

\lstinputlisting{\CURPATH/test_circular}

Первые две ячейки последнего ряда (C0 и C1) завязаны друг на друга.
Наша программа просто скажет ``unsat'', означая, что она не смогла удовлетворить все констрайнты.
Мы не можем это использовать как сообщение об ошибке для конечного пользователя, потому что от него мало толка.

Хотя, мы можем вытащить \textit{unsat core}, т.е., список переменных, которые для Z3 являются конфликтующими.

\begin{lstlisting}
...
s=Solver()
s.set(unsat_core=True)
...
        # add constraint:
        s.assert_and_track(e, coord_to_name(cur_R, cur_C))
...
if result=="sat":
...
else:
    print s.unsat_core()
\end{lstlisting}

( \url{.../spreadsheet_Z3_2.py} )

Нам нужно явно включить поддержку unsat core и использовать \textit{assert\_and\_track()} вместо метода \textit{add()},
потому что эта возможность замедляет весь процесс, и по умолчанию отключена.
Это работает:

\begin{lstlisting}
 % python 2.py test_circular
unsat
[C0, C1]
\end{lstlisting}

Вероятно, эти переменные могут быть удалены из двухмерного массива, маркированы как \textit{unresolved},
и вся таблица могла бы быть пересчитанной заново.

\subsubsection{Нагрузочное тестирование}

Как сгенерировать большую случайную электронную таблицу?
Вот что мы можем сделать.
В начале создаем случайный \ac{DAG}, как вот этот:

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{\CURPATH/1.png}
\caption{Случайный DAG}
\end{figure}

Стрелки определяют потоки информации.
Так что узел графа, который не имеет входящих стрелок (indegree=0), может быть установлен в случайное число.
Затем мы используем топологическую сортировку для поиска зависимостей между узлами графа.
Затем мы назначаем имена ячеек каждому узлу.
Затем мы генерируем случайное выражение со случайными операциями/числами/ячейками, используя информацию
полученную из топологически отсортированного графа.

\input{\CURPATH/math}

Вот вывод ф-ции \textit{Grid[]}:

\input{\CURPATH/grid.tex}

Используя этот скрипт, я могу сгенерировать случайную электронную таблицу из $26 \cdot 500=13000$ ячеек,
которая затем обрабатывается Z3 несколько секунд.

\subsubsection{Файлы}

Файлы, включая файл для Mathematica: \url{.../spreadsheet}.

