\subsection{Взлом Сапёра при помощи SAT}
\label{minesweeper_SAT}

См.также о взломе оного при помощи Z3: \ref{minesweeper_SMT}.

\subsubsection{Простая ф-ция подсчета бит (\textit{population count})}

Прежде всего, нам нужно как считать количество соседних бомб.
Ф-ция подсчета та же, что и ф-ция подсчета бит (\textit{population count}).

Мы можем создать \ac{CNF}-выражение используя Wolfram Mathematica.
Это будет ф-ция, возвращающая \textit{True} если любые из двух бит 8-битного входа равняются \textit{True},
а остальные --- \textit{False}.
В начале, сделаем таблицу истинности для такой ф-ции:

\begin{lstlisting}
In[]:= tbl2 = 
 Table[PadLeft[IntegerDigits[i, 2], 8] -> 
   If[Equal[DigitCount[i, 2][[1]], 2], 1, 0], {i, 0, 255}]

Out[]= {{0, 0, 0, 0, 0, 0, 0, 0} -> 0, {0, 0, 0, 0, 0, 0, 0, 1} -> 0, 
{0, 0, 0, 0, 0, 0, 1, 0} -> 0, {0, 0, 0, 0, 0, 0, 1, 1} -> 1, 
{0, 0, 0, 0, 0, 1, 0, 0} -> 0, {0, 0, 0, 0, 0, 1, 0, 1} -> 1, 
{0, 0, 0, 0, 0, 1, 1, 0} -> 1, {0, 0, 0, 0, 0, 1, 1, 1} -> 0, 
{0, 0, 0, 0, 1, 0, 0, 0} -> 0, {0, 0, 0, 0, 1, 0, 0, 1} -> 1, 
{0, 0, 0, 0, 1, 0, 1, 0} -> 1, {0, 0, 0, 0, 1, 0, 1, 1} -> 0, 
...
{1, 1, 1, 1, 1, 0, 1, 0} -> 0, {1, 1, 1, 1, 1, 0, 1, 1} -> 0, 
{1, 1, 1, 1, 1, 1, 0, 0} -> 0, {1, 1, 1, 1, 1, 1, 0, 1} -> 0, 
{1, 1, 1, 1, 1, 1, 1, 0} -> 0, {1, 1, 1, 1, 1, 1, 1, 1} -> 0}
\end{lstlisting}

Теперь можем сделать \ac{CNF}-выражение используя эту таблицу истинности:

\begin{lstlisting}
In[]:= BooleanConvert[
 BooleanFunction[tbl2, {a, b, c, d, e, f, g, h}], "CNF"]

Out[]= (! a || ! b || ! c) && (! a || ! b || ! d) && (! a || ! 
    b || ! e) && (! a || ! b || ! f) && (! a || ! b || ! g) && (! 
    a || ! b || ! h) && (! a || ! c || ! d) && (! a || ! c || ! 
    e) && (! a || ! c || ! f) && (! a || ! c || ! g) && (! a || ! 
    c || ! h) && (! a || ! d || ! e) && (! a || ! d || ! f) && (! 
    a || ! d || ! g) && (! a || ! d || ! h) && (! a || ! e || ! 
    f) && (! a || ! e || ! g) && (! a || ! e || ! h) && (! a || ! 
    f || ! g) && (! a || ! f || ! h) && (! a || ! g || ! h) && (a || 
   b || c || d || e || f || g) && (a || b || c || d || e || f || 
   h) && (a || b || c || d || e || g || h) && (a || b || c || d || f ||
    g || h) && (a || b || c || e || f || g || h) && (a || b || d || 
   e || f || g || h) && (a || c || d || e || f || g || 
   h) && (! b || ! c || ! d) && (! b || ! c || ! e) && (! b || ! 
    c || ! f) && (! b || ! c || ! g) && (! b || ! c || ! h) && (! 
    b || ! d || ! e) && (! b || ! d || ! f) && (! b || ! d || ! 
    g) && (! b || ! d || ! h) && (! b || ! e || ! f) && (! b || ! 
    e || ! g) && (! b || ! e || ! h) && (! b || ! f || ! g) && (! 
    b || ! f || ! h) && (! b || ! g || ! h) && (b || c || d || e || 
   f || g || 
   h) && (! c || ! d || ! e) && (! c || ! d || ! f) && (! c || ! 
    d || ! g) && (! c || ! d || ! h) && (! c || ! e || ! f) && (! 
    c || ! e || ! g) && (! c || ! e || ! h) && (! c || ! f || ! 
    g) && (! c || ! f || ! h) && (! c || ! g || ! h) && (! d || ! 
    e || ! f) && (! d || ! e || ! g) && (! d || ! e || ! h) && (! 
    d || ! f || ! g) && (! d || ! f || ! h) && (! d || ! g || ! 
    h) && (! e || ! f || ! g) && (! e || ! f || ! h) && (! e || ! 
    g || ! h) && (! f || ! g || ! h)
\end{lstlisting}

Синтаксис такой же как и в Си/Си++
Проверим.

Я написал Питоновскую ф-цию для конвертирования вывода Mathematica в \ac{CNF}-файл, который можно подать на вход
SAT-солверу:

\lstinputlisting{SAT/minesweeper/tst.py}

Она заменяет переменные a/b/c/... на переданные имена переменных (1/2/3...), перерабатыает синтаксис, итд.
Вот результат:

\lstinputlisting{SAT/minesweeper/tst1.cnf}

Могу запустить:

\begin{lstlisting}
% minisat -verb=0 tst1.cnf results.txt
SATISFIABLE

% cat results.txt
SAT
1 -2 -3 -4 -5 -6 -7 8 0
\end{lstlisting}

Имя переменной в результате без знака минуса, это \textit{True}.
Имя переменной со знаком минус, это \textit{False}.
Мы здесь видим только две переменных \textit{True}: 1 и 8.
Это действительно корректно: солвер MiniSat нашел условие, для которого наша ф-ция возвращает \textit{True}.
Ноль в конце это просто терминирующий символ, который ничего не означает.

Мы можем попросить MiniSat найти еще одно решение, добавив текущее решение во входной CNF-файл,
но где все переменные инвертированы:

\begin{lstlisting}
...
-5 -6 -8 0
-5 -7 -8 0
-6 -7 -8 0
-1 2 3 4 5 6 7 -8 0
\end{lstlisting}

В обычном русском языке, это означает ``дайте ЛЮБОЕ решение, которые удовлетворяет все клозы, но также не равно
последнему клозу, которое мы только что добавили''.

MiniSat, действительно, находит еще одно решение, и снова, только с двумя переменными, равными \textit{True}:

\begin{lstlisting}
% minisat -verb=0 tst2.cnf results.txt
SATISFIABLE

% cat results.txt
SAT
1 2 -3 -4 -5 -6 -7 -8 0
\end{lstlisting}

Кстати, ф-ция \textit{population count} для 8-и соседей (POPCNT8) в CNF-форме, самая простая:

\begin{lstlisting}
a&&b&&c&&d&&e&&f&&g&&h
\end{lstlisting}

Действительно: она истинна, если все 8 входных бит тоже истинны.

Ф-ция для отсутствия соседей (POPCNT0) тоже очень простая:

\begin{lstlisting}
!a&&!b&&!c&&!d&&!e&&!f&&!g&&!h
\end{lstlisting}

Это означает, что она вернет \textit{True}, если все входные переменные \textit{False}.

Кстати, ф-ция POPCNT1 тоже простая:

\begin{lstlisting}
(!a||!b)&&(!a||!c)&&(!a||!d)&&(!a||!e)&&(!a||!f)&&(!a||!g)&&(!a||!h)&&(a||b||c||d||e||f||g||h)&&
(!b||!c)&&(!b||!d)&&(!b||!e)&&(!b||!f)&&(!b||!g)&&(!b||!h)&&(!c||!d)&&(!c||!e)&&(!c||!f)&&(!c||!g)&&
(!c||!h)&&(!d||!e)&&(!d||!f)&&(!d||!g)&&(!d||!h)&&(!e||!f)&&(!e||!g)&&(!e||!h)&&(!f||!g)&&(!f||!h)&&(!g||!h)
\end{lstlisting}

Здесь просто перечисление всех возможных пар 8-и переменных
(a/b, a/c, a/d, итд), что подразумевает: не должно присутствовать одновременно двух бит в каждой возможной паре.
И еще один клоз: ``(a||b||c||d||e||f||g||h)'', что подразумевает: минимум один бит должен присутствовать
среди 8-и переменных.

И да, вы можете использовать Mathematica для поиска \ac{CNF}-выражения для любой другой таблицы истинности.

\subsubsection{Сапёр}

Теперь можем использовать Mathematica для генерации всех ф-ций \textit{population count} для количества соседей 0..8.

Для Сапёра с матрицей $9 \cdot 9$ включая невидимую рамку, здесь будет $11 \cdot 11=121$ переменных,
связанных с матрицей Сапёра вот так:

\begin{lstlisting}
 1    2   3   4   5   6   7   8   9  10  11
12   13  14  15  16  17  18  19  20  21  22
23   24  25  26  27  28  29  30  31  32  33
34   35  36  37  38  39  40  41  42  43  44

...

100 101 102 103 104 105 106 107 108 109 110
111 112 113 114 115 116 117 118 119 120 121
\end{lstlisting}

Потом мы пишем Питоновский скрипт, складывающий все ф-ции \textit{population count}:
каждая ф-ция для каждого известного числа соседей (число на поле Сапёра).
Каждая ф-ция POPCNTx() берет на вход список переменных и выдает список клозов, которые будут добавлены
в итоговый \ac{CNF}-файл.

Что до пустых клеток, мы тоже добавляем их как клозы, но со знаком минус, что означает, что переменная
должна быть \textit{False}.
А когда мы пытаемся поместить бомбу, мы добавляем её переменную как клоз без знака минуса, что означает
что переменная должна быть \textit{True}.

Затем запускаем внешний процесс minisat.
Всё что нам от него нужно, это код возврата.
Если входной \ac{CNF} это \TT{UNSAT}, он возвращает 20:

Мы также используем здесь информацию из предыдущего решения Сапёра: \ref{minesweeper_SMT}.

\lstinputlisting{SAT/minesweeper/minesweeper_SAT.py}

( \url{https://github.com/DennisYurichev/SAT_SMT_article/blob/master/SAT/minesweeper/minesweeper_SAT.py} ) \\
\\
Выходной \ac{CNF}-файл большой, вплоть до $\approx 2000$ клозов, и даже больше, вот, например: \url{https://github.com/DennisYurichev/SAT_SMT_article/blob/master/SAT/minesweeper/sample.cnf}.

Так или иначе, это работает так же, как мой предыдущий скрипт для Z3Py:

\begin{lstlisting}
row=1, col=3, unsat!
row=6, col=2, unsat!
row=6, col=3, unsat!
row=7, col=4, unsat!
row=7, col=9, unsat!
row=8, col=9, unsat!
\end{lstlisting}

\dots но работает намного быстрее, даже учитывая запуск внешней программы.
Вероятно, версию для Z3Py можно было бы оптимизировать получше?

Файлы, включая файл для Wolfram Mathematica: \url{https://github.com/DennisYurichev/SAT_SMT_article/tree/master/SAT/minesweeper}.

