\subsection{Sudoku в SAT}
\label{Sudoku_SAT}

Кто-то может подумать, что мы можем закодировать каждое число 1..9 в двоичном виде: 5 бит или переменных было бы достаточно.
Но есть даже еще более простой способ: выделить 9 бит, где только один бит будет \textit{Истинен}.
Число 1 может быт закодировано как [1, 0, 0, 0, 0, 0, 0, 0, 0], число 3 как [0, 0, 1, 0, 0, 0, 0, 0, 0], итд.
Выглядит неэкономично? Да, но другие операции будут проще.

Прежде всего, мы будем снова использовать важную ф-цию \TT{POPCNT1}, которую я описывал раннее: \ref{POPCNTOne}.

Вторая нужная нам важная операция, которую нам нужно придумать, это как сделать 9 чисел уникальными.
Если каждое число закодировано как 9-битный вектор, 9 чисел могут сформировать матрицу, вроде:

\begin{lstlisting}
0 0 0 0 0 0 1 0 0 <- §1-е§ число
0 0 0 0 0 1 0 0 0 <- §2-е§ число
0 1 0 0 0 0 0 0 0 <- ...
0 0 1 0 0 0 0 0 0 <- ...
0 0 0 0 0 0 0 0 1 <- ...
0 0 0 0 1 0 0 0 0 <- ...
0 0 0 0 0 0 0 1 0 <- ...
1 0 0 0 0 0 0 0 0 <- ...
0 0 0 1 0 0 0 0 0 <- §9-е§ число
\end{lstlisting}

Теперь будем использовать ф-цию \TT{POPCNT1} чтобы сделать каждый ряд в матрице содержащим только один бит \textit{Истина},
и это будет сохранять корректность нашего способа кодирования, т.к., вектор не может иметь более одного бита \textit{Истина},
либо не иметь битов \textit{Истина} вообще.
Затем мы будем использовать ф-цию \TT{POPCNT1} снова чтобы сделать так, чтобы каждый столбец в матрице имел только
один единственный бит \textit{Истина}.
Это сделает все ряды в матрице уникальными, другими словами, все 9 закодированных чисел всегда будут уникальными.

После применения ф-ции \TT{POPCNT1} 9+9=18 раз, у нас будет 9 уникальных чисел в пределах 1..9.

Используя эту операцию мы можем сделать каждый ряд в головоломке Судоку уникальным, каждый столбец уникальным,
и каждый квадрат $3 \cdot 3=9$ тоже уникальным.

\lstinputlisting{SAT/sudoku/sudoku_SAT.py}
( \url{https://github.com/DennisYurichev/SAT_SMT_article/blob/master/SAT/sudoku/sudoku_SAT.py} )

Ф-ция \TT{make\_distinct\_bits\_in\_vector()} сохраняет корректность кодирования.\\
Ф-ция \TT{make\_distinct\_vectors()} делает 9 чисел уникальными.\\
Ф-ция \TT{cvt\_vector\_to\_number()} декодирует вектор в число.\\
Ф-ция \TT{number\_to\_vector()} кодирует число в вектор.\\
Ф-ция \TT{main()} содержит все необходимые вызовы, чтобы сделать уникальными ряды/столбцы и квадраты $3\cdot 3$.

Работает:

\begin{lstlisting}
% python sudoku_SAT.py
len(clauses)= 12195
1 4 5 3 2 7 6 9 8
8 3 9 6 5 4 1 2 7
6 7 2 9 1 8 5 4 3
4 9 6 1 8 5 3 7 2
2 1 8 4 7 3 9 5 6
7 5 3 2 9 6 4 8 1
3 6 7 5 4 2 8 1 9
9 8 4 7 6 1 2 3 5
5 2 1 8 3 9 7 6 4
\end{lstlisting}

Такое же решение как и раннее: \ref{sudoku_SMT}.

Picosat говорит что эта SAT-проблема имеет только одно решение.
Действительно, как говорят, настоящая головоломка Судоку может иметь только одно решение.

\subsubsection{Избавление от одного вызова POPCNT1}
\label{OR_in_POPCNT1}

Чтобы сделать 9 уникальный чисел 1..9 мы можем использовать ф-цию \TT{POPCNT1}, чтобы сделать уникальным каждый ряд
в матрице, и использовать операцию \textit{ИЛИ} для всех столбцов.
Это будет иметь такой же эффект: все ряды должны быть уникальны, чтобы каждый столбец вычислялся в \textit{Истино}
после применения операции \textit{ИЛИ} ко всем переменным в столбце.
(Я буду делать так в следующем примере: \ref{Zebra_SAT}.)

Это приведет к тому, что будет 3447 клозов вместо 12195, но почему-то, SAT-солверы работают медленнее. Не знаю, почему.

