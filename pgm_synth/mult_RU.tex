\subsection{Синтез простой программы используя Z3}

Иногда, операция умножения может быть заменена на несколько операций сдвигов/сложения/вычитания.
Компиляторы так делают, потому что пачка таких инструкций может исполнятся быстрее.

Например, GCC 5.4 заменяет умножение на 19 на пару инструкций: \TT{lea edx, [eax+eax*8]} и\\
\TT{lea eax, [eax+edx*2]}.
Иногда это называется ``супероптимизация''.

Посмотрим, сможем ли мы находить кратчайшую из возможных пачку инструкций для некоторого указанного множителя.

Как я уже отмечал, SMT-солвер можно представить как солвер огромной системы уравнений.
Проблема в том, чтобы сконструировать такую систему уравнений, которая, при решении, выдаст короткую программу.
Чтобы было проще, я буду использовать здесь аналогии с электроникой.

Прежде всего, из чего будет состоять наша программа? Доступно три операции: ADD/SUB/SHL.
В качестве операндов будут доступны только регистры, за исключением второго операнда SHL
(который может быть в пределах 1..31).
Каждый регистр будет присваиваться только один раз (как в случае с \ac{SSA}).

И будет некий ``магический блок'', берущий на вход предыдущие состояния всех регистров, также будет брать тип операции,
операнды и будет выдавать значение следующего состояния регистра.

% FIXME: font
\begin{lstlisting}
	        op ------------+
	        op1_reg -----+ |
	        op2_reg ---+ | |
	                   | | |
	                   v v v
	             +---------------+
	             |               |
	registers -> |               | -> new register's state
	             |               |
	             +---------------+
\end{lstlisting}

Посмотрим на схему на самом высоком уровне:

\begin{lstlisting}
	0 -> blk -> blk -> blk .. -> blk -> 0

	1 -> blk -> blk -> blk .. -> blk -> множитель
\end{lstlisting}

Каждый блок берет предыдущее состояние регистров и выдает новые состояния.
Здесь две цепи.
Первая цепь берет 0 как состояние R0 в самом начале, и эта цепь должна выдать 0 в конце
(т.к., 0 умноженный на любое значение это тоже 0).
Вторая цепь берет 1 и должна выдать множитель как состояние самого последнего регистра
(т.к., 1 умноженное на множитель должно равняться множителю).

Каждый блок ``управляется'' типом операции, операндами, итд.
Для каждого столбца, есть свой набор.

Теперь вы можете рассматривать эти две цепи как два уравнения.
Конечная цель в том, чтобы найти такое состояние для всех типов операций и операндов, чтобы первая цепь
была равна нулю, а вторая --- множителю.

Посмотрим внутрь ``магического блока'':

% FIXME: font
\begin{lstlisting}
	                op1_reg         op
	                   |            v
	                   v         +-----+
	 регистры ---> selector1 --> | ADD |
	           +                 | SUB | ---> результат
	           |                 | SHL |
	           +-> selector2 --> +-----+
	                  ^             ^
	                  |             |
	               op2_reg       op2_imm
\end{lstlisting}

Каждый селектор можно рассматривать как простой многопозиционный переключатель.
Если операция SHL, тогда значение в пределах 1..31 используется как второй операнд.

Так что вы можете представить эту электронную схему, и ваша цель в том, чтобы переключить все переключатли в то состояние,
когда обе цепи будут иметь на выходе 0 и множитель.
Это звучит как логическая головоломка.
Теперь попробуем использовать Z3 для решения этой головоломки.

В начале, определим все переменные:

\begin{lstlisting}
R=[[BitVec('S_s%d_c%d' % (s, c), 32) for s in range(MAX_STEPS)] for c in range (CHAINS)]
op=[Int('op_s%d' % s) for s in range(MAX_STEPS)]
op1_reg=[Int('op1_reg_s%d' % s) for s in range(MAX_STEPS)]
op2_reg=[Int('op2_reg_s%d' % s) for s in range(MAX_STEPS)]
op2_imm=[BitVec('op2_imm_s%d' % s, 32) for s in range(MAX_STEPS)]
\end{lstlisting}

R[][] это состояние регистров для каждой цепи и каждого шага.\\
И наоборот, переменные \TT{op}/\TT{op1\_reg}/\TT{op2\_reg}/\TT{op2\_imm} определены для каждого шага, но для обоих цепей,
т.к., обе цепи на каждом столбце имеют одну и ту же операцию и операнды.

Теперь нужно ограничить количество операций, а также количество регистров для каждого шага не должно быть больше чем
номер шага, другими словами, инструкция на каждом шаге имеет право использовать только те регистры, которые были
выставлены перед этим:

\begin{lstlisting}
for s in range(1, STEPS):
    # for each step
    sl.add(And(op[s]>=0, op[s]<=2))
    sl.add(And(op1_reg[s]>=0, op1_reg[s]<s))
    sl.add(And(op2_reg[s]>=0, op2_reg[s]<s))
    sl.add(And(op2_imm[s]>=1, op2_imm[s]<=31))
\end{lstlisting}

Установить регистр на первом шаге для обоих цепей:

\begin{lstlisting}
for c in range(CHAINS):
    # for each chain:
    sl.add(R[c][0]==chain_inputs[c])
    sl.add(R[c][STEPS-1]==chain_inputs[c]*multiplier)
\end{lstlisting}

Теперь добавим ``магические блоки'':

\begin{lstlisting}
for s in range(1, STEPS):
    sl.add(R[c][s]==simulate_op(R,c, op[s], op1_reg[s], op2_reg[s], op2_imm[s]))
\end{lstlisting}

Как определен ``магический блок''?

\begin{lstlisting}
def selector(R, c, s):
    # for all MAX_STEPS:
    return If(s==0, R[c][0],
	    If(s==1, R[c][1],
            If(s==2, R[c][2],
	    If(s==3, R[c][3],
            If(s==4, R[c][4],
            If(s==5, R[c][5],
	    If(s==6, R[c][6],
            If(s==7, R[c][7],
	    If(s==8, R[c][8],
            If(s==9, R[c][9],
	        0)))))))))) # default

def simulate_op(R, c, op, op1_reg, op2_reg, op2_imm):
    op1_val=selector(R,c,op1_reg)
    return If(op==0, op1_val + selector(R, c, op2_reg),
	   If(op==1, op1_val - selector(R, c, op2_reg),
           If(op==2, op1_val << op2_imm,
	       0))) # default
\end{lstlisting}

Это очень важно понимать: если операция ADD/SUB, тогда значение \TT{op2\_imm} просто игнорируется.
Иначе, если операция SHL, значение \TT{op2\_reg} игнорируется.
Просто как в случае с электронной схемой.

Код: \url{https://github.com/DennisYurichev/SAT_SMT_article/blob/master/pgm_synth/mult.py}.

Теперь посмотрим, как это работает:

\begin{lstlisting}
% ./mult.py 12
multiplier= 12
attempt, STEPS= 2
unsat
attempt, STEPS= 3
unsat
attempt, STEPS= 4
sat!
r1=SHL r0, 2
r2=SHL r1, 1
r3=ADD r1, r2
tests are OK
\end{lstlisting}

Первый шаг это шаг, всегда имеющий 0/1 или r0.
Так что, если солвер показывает 4 шага, это означает 3 инструкции.

Это потяжелее:

\begin{lstlisting}
% ./mult.py 123
multiplier= 123
attempt, STEPS= 2
unsat
attempt, STEPS= 3
unsat
attempt, STEPS= 4
unsat
attempt, STEPS= 5
sat!
r1=SHL r0, 2
r2=SHL r1, 5
r3=SUB r2, r1
r4=SUB r3, r0
tests are OK
\end{lstlisting}

Код умножающий на 1234:

\begin{lstlisting}
r1=SHL r0, 6
r2=ADD r0, r1
r3=ADD r2, r1
r4=SHL r2, 4
r5=ADD r2, r3
r6=ADD r5, r4
\end{lstlisting}

Выглядит неплохо, но это заняло $\approx 23$ секунды на моем Intel Xeon CPU E31220 @ 3.10GHz.
Согласен, это далеко от практического применения.
Также, я совсем не уверен, что этот фрагмент кода будет работать быстрее, чем одна инструкция умножения.
Но тем не менее, это хорошая демонстрация возможностей SMT-солверов.

Этот код умножает на 12345 ($\approx 150$ секунд):

\begin{lstlisting}
r1=SHL r0, 5
r2=SHL r0, 3
r3=SUB r2, r1
r4=SUB r1, r3
r5=SHL r3, 9
r6=SUB r4, r5
r7=ADD r0, r6
\end{lstlisting}

Умножение на 123456 ($\approx 8$ минут!):

\begin{lstlisting}
r1=SHL r0, 9
r2=SHL r0, 13
r3=SHL r0, 2
r4=SUB r1, r2
r5=SUB r3, r4
r6=SHL r5, 4
r7=ADD r1, r6
\end{lstlisting}

\subsubsection{Некоторые замечания}

Я убрал поддержку инструкции SHR, просто потому что код, умножающий на константу, не использует её.
И дажее более того: нет проблем добавить поддержку констант как второго операнда для всех инструкций,
но снова, вы не найдете фрагмента кода, который делает то, что нам нужно, и использует дополнительные константы.
Или я ошибаюсь?

Конечно, для другой работы, вам понадобится поддержка констант и других операций.
Но в то время, всё это будет работать медленее и медленнее.
Так что мне пришлось сделать \ac{ISA} этого игрушечного \ac{CPU} как можно более компактным.

\subsubsection{Код}

\url{https://github.com/DennisYurichev/SAT_SMT_article/blob/master/pgm_synth/mult.py}.

